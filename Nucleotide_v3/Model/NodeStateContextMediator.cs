//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using Nucleotide_v3.Exceptions;
using Nucleotide_v3.States;

namespace Nucleotide_v3.Model
{
    [Serializable]
    /// <summary>
    /// This class should expose access to the Incidence and Adjacency providers. 
    /// These providers are protected internal to ensure that we can later extend 
    /// this class to an implementation that provides improved performance and data storage.
    /// </summary>
    public class NodeStateContextMediator<E,V> 
        where E : EdgeNodeStateContext, new() 
        where V: VertexNodeStateContext, new()
    {
        protected internal class UndirectedAdjacencyProvider : AdjacencyProvider
        {
           
            /* To add a new vertex, we need to do this: 
                    for each array, 
                        CopyTo an array with larger size by +1
             * We must lock the collection during enumeration to ensure thread-safety.
             * 
                   */
            //bool[][] Values { get; set; }
            public UndirectedAdjacencyProvider()
            {
                Values = new Dictionary<int, Dictionary<int, bool>>();
            }

            //public UndirectedAdjacencyMatrix(int size)
            //{
            //    Values = new bool[size][];
            //    for (int i = 0; i < size; i++)
            //    {
            //        Values[i] = new bool[size];
            //        for (int j = 0; j < size; j++)
            //        {
            //            Values[i][j] = false;
            //        }
            //    }

            //}
            // For thread-safe enumeration, see: http://www.codeproject.com/Articles/56575/Thread-safe-enumeration-in-C
            public void Add(int vertexPosition, ErrorOnDuplicate errorOnDuplicate)
            {
                lock (Values)
                {
                    // first we must check if the vertexPosition is larger than size of array.
                    var currentRowCount = Values.Count;
                    if (vertexPosition < currentRowCount)
                    {
                        // then we must check if the identity element is true. If so, the array is already occupied there, so throw an exception.
                        if (Values.ContainsKey(vertexPosition) && Values[vertexPosition].ContainsKey(vertexPosition))
                        {
                            if (Values[vertexPosition][vertexPosition] == true)
                            {
                                if (errorOnDuplicate == ErrorOnDuplicate.Yes)
                                {
                                    throw new DuplicateNameException(
                                    "Error: Element already exists at specified position in UndirectedAdjacencyMatrix.");
                                }
                                // else, do nothing.

                            }
                            else
                            {
                                // Else, we can set the identity for that position to true.
                                Values[vertexPosition][vertexPosition] = true;
                            }
                        }
                    }
                    else
                    {
                        var rowCountDiff = vertexPosition - currentRowCount; // 2 = 10 - 8.
                        for (int i = 0; i <= rowCountDiff; i++)
                        {
                            // for each place in the gap, we must construct a row with size equal to our new position.
                            var newRow = new Dictionary<int, bool>(vertexPosition);
                            // we need to first initialize the values of the new row.
                            for (int j = 0; j <= vertexPosition; j++)
                            // the number of column values we must add increases with the number of rows.
                            {
                                newRow.Add(j, false); // initialize to default as false.
                            }
                            // Values.AddVertex(i + size -1,newRow); // Use this line if we get out of bounds exception.
                            Values.Add(i + currentRowCount, newRow); // These keys must be new (>i) because we are adding the elements to the end of the list.
                            // If any rows have fewer elements (i.e. columns) than newRow, we must add elements (false) to them.
                            // Get rows that have fewer elements than newRow.
                            var newRowColumns = newRow.Count;
                            for (int j = 0; j < Values.Count; j++) // < or <= ??
                            {
                                int currentColumnCount = Values[j].Count;
                                if (currentColumnCount < newRow.Count) // i.e. if our rows don't yet have same numbers of columns.
                                {
                                    var columnCountDiff = newRowColumns - currentColumnCount; // i.e. get the diff for the starting index position of new columns
                                    for (int k = 0; k < columnCountDiff; k++)
                                    {
                                        Values[j].Add(k + currentColumnCount, false);
                                        // AddVertex default elements to the row until the number of elements matches newRow.
                                    }
                                }
                            }

                            // At this point, all of the rows should have equal numbers of columns.

                            for (int j = 0; j < vertexPosition; j++)
                            {
                                // all of the new row values should be false except for the row value at our vertexPosition.
                                var pos = currentRowCount + i;
                                var row = Values[pos];
                                Values[currentRowCount + i][j] = false;
                            }
                        }
                        Values[vertexPosition][vertexPosition] = true;
                    }   
                }
            }

            protected internal override void AddVertex(int vertexPosition)
            {
                Add(vertexPosition, ErrorOnDuplicate.No);
            }

            protected internal override bool AreVerticesBothAdjacent(int vertexPosition1, int vertexPosition2)
            {
                return AreVerticesBothAdjacent(vertexPosition1, vertexPosition2, ErrorOnMissing.No);
            }

            protected internal override void SetVertices(int vertexPosition1, int vertexPosition2)
            {
                SetAdjacentVertices(vertexPosition1, vertexPosition2,AddVertexToMatrixIfMissing.Yes);
            }

            protected internal override void SetVertices(int vertexPosition1, IEnumerable<int> vertexPositions)
            {
                var vertexPositionList = vertexPositions.ToList();
                lock (vertexPositionList)
                {
                    SetAdjacentVertices(vertexPosition1, vertexPositionList, AddVertexToMatrixIfMissing.Yes);
                }
            }

            protected internal override void UnsetVertices(int vertexPosition1, int vertexPosition2)
            {
                UnsetAdjacencyVertices(vertexPosition1, vertexPosition2, ErrorOnMissing.Yes);
            }
            public void UnsetAdjacencyVertices(int vertexPosition1, int vertexPosition2, ErrorOnMissing errorOnMissing)
            {
                lock (Values)
                {
                    var vertex1InMatrix = this.IsVertexInMatrix(vertexPosition1);
                    var vertex2InMatrix = this.IsVertexInMatrix(vertexPosition2);
                    #region checkIfMissing
                    if (errorOnMissing == ErrorOnMissing.Yes) // i.e. If we are not to add the vertex if it doesn't exist in the matrix:
                    {
                        // then if vertices are not in the matrix yet, throw an exception.
                        if (!vertex1InMatrix)
                        {
                            throw new ArgumentOutOfRangeException("vertexPosition1", "Vertex does not exist in matrix yet!");
                        }
                        if (!vertex2InMatrix)
                        {
                            throw new ArgumentOutOfRangeException("vertexPosition2", "Vertex does not exist in matrix yet!");
                        }
                    }
                    if (errorOnMissing == ErrorOnMissing.No)
                    {
                        if (!vertex1InMatrix)  // then if vertices are not in the matrix yet, they should be added.
                        {
                            this.AddVertex(vertexPosition1);
                        }
                        if (!vertex2InMatrix)
                        {
                            this.AddVertex(vertexPosition2);
                        }

                    }
                    #endregion
                    // Now that both vertices are included in the matrix, we can set their adjacencies.
                    // This means vertexPosition1 should be true at vertexPosition2
                    //      and vertexPosition2 should be true at vertexPosition1.
                    Values[vertexPosition1][vertexPosition2] = false;
                    Values[vertexPosition2][vertexPosition1] = false;
                }
            
            }
            /// <summary>
            /// 
            /// </summary>
            /// <param name="vertexPosition1"></param>
            /// <param name="vertexPosition2"></param>
            /// <param name="errorOnMissing">If set to No, then this method returns false if the specified vertex does not exist in this matrix.</param>
            /// <returns></returns>
            [Obsolete("This method has performance limitations. Otherwise, it works.")]
            public AreVerticesAdjacent HowVerticesBothAdjacent(int vertexPosition1, int vertexPosition2)
            {
                lock (Values)
                {
                    var isVertex1InMatrix = IsVertexInMatrix(vertexPosition1);
                    var isVertex2InMatrix = IsVertexInMatrix(vertexPosition2);
                    if (!isVertex1InMatrix || !isVertex2InMatrix)
                    {
                        return AreVerticesAdjacent.VertexIsMissingFromMatrix;
                    }
                    var adjacentToVertexPosition1 = this.GetAdjacentVertices(vertexPosition1);
                    var adjacentToVertexPosition2 = this.GetAdjacentVertices(vertexPosition2);
                    var adjacentTo1Contains2 = adjacentToVertexPosition1.Contains(vertexPosition2);
                    var adjacentTo2Contains1 = adjacentToVertexPosition2.Contains(vertexPosition1);
                    if (adjacentTo1Contains2 && adjacentTo2Contains1)
                    {
                        return AreVerticesAdjacent.BothVerticesAreAdjacent;
                    }
                    if (adjacentTo1Contains2)
                    {
                        return AreVerticesAdjacent.SourceVertexIsAdjacentToTarget;
                    }
                    if (adjacentTo2Contains1)
                    {
                        return AreVerticesAdjacent.TargetVertexIsAdjacentToSource;
                    }
                    return AreVerticesAdjacent.NeitherVerticesAreAdjacent;
                }
            
            }

            protected internal override bool AreVerticesBothAdjacentAndUncut<E,V>(NodeStateContextMediator<E, V> mediator, int vertexPosition1, int vertexPosition2)
            {
                return this.AreVerticesBothAdjacentAndUncut(mediator, vertexPosition1, vertexPosition2, ErrorOnMissing.No);
            }

            //protected internal override bool AreVerticesBothAdjacentAndUncut(NodeStateContextMediator<E, V> mediator, int vertexPosition1, int vertexPosition2)
            //{
            //    return this.AreVerticesBothAdjacentAndUncut(mediator, vertexPosition1, vertexPosition2, ErrorOnMissing.No);
            //}


            public bool AreVerticesBothAdjacentAndUncut<E, V>(NodeStateContextMediator<E, V> mediator, int vertexPosition1, int vertexPosition2, ErrorOnMissing errorOnMissing)
            where E:EdgeNodeStateContext, new() 
            where V:VertexNodeStateContext, new()
            {
                if (AreVerticesBothAdjacent(vertexPosition1, vertexPosition2, errorOnMissing))
                {
                    var edgeBetweenThem = mediator.GetEdgeIncidentToBothVertices(vertexPosition1, vertexPosition2);
                    if (edgeBetweenThem != null && !edgeBetweenThem.State.Equals(CutEdgeNodeState.Instance))
                    {
                        return true;
                    }
                }
                return false;
            }

            public bool AreVerticesBothAdjacent(int vertexPosition1, int vertexPosition2, ErrorOnMissing errorOnMissing)
            {
                lock (Values)
                {
                    var isVertex1InMatrix = IsVertexInMatrix(vertexPosition1);
                    var isVertex2InMatrix = IsVertexInMatrix(vertexPosition2);
                    if (errorOnMissing == ErrorOnMissing.Yes)
                    {
                        if (!isVertex1InMatrix && !isVertex2InMatrix)
                        {
                            throw new ArgumentOutOfRangeException("vertexPosition1, vertexPosition2", "Provided vertices do not exist in matrix!");
                        }
                        if (!isVertex1InMatrix)
                        {
                            throw new ArgumentOutOfRangeException("vertexPosition1", "Provided vertex does not exist in matrix!");
                        }
                        if (!isVertex2InMatrix)
                        {
                            throw new ArgumentOutOfRangeException("vertexPosition2", "Provided vertex does not exist in matrix!");
                        }
                    }
                    if (errorOnMissing == ErrorOnMissing.No)
                    {
                        if (!isVertex1InMatrix || !isVertex2InMatrix)
                        {
                            return false;
                        }
                    }
                    var vertex2AdjacentToVertex1 = Values[vertexPosition1][vertexPosition2];
                    var vertex1AdjacentToVertex2 = Values[vertexPosition2][vertexPosition1];
                    if (vertex1AdjacentToVertex2 && vertex2AdjacentToVertex1)
                    {
                        return true;
                    }
                    return false;
                }
            }
            /// <summary>
            /// These positions are zero-indexed! This sets the undirected adjacency values to true for the matrix.
            /// Note: If the values are not yet part of the matrix, AddVertexToMatrixIfMissing allows you to specify if they should be
            /// added or if an exception should be thrown.
            /// </summary>
            /// <param name="vertexPosition1"></param>
            /// <param name="vertexPosition2"></param>
            /// <param name="addVertexToMatrixIfMissing">This parameter specifies if the vertices should be added to the matrix if their identities do not exist in the matrix yet.</param>
            /// <returns></returns>
            public void SetAdjacentVertices(int vertexPosition1, int vertexPosition2, AddVertexToMatrixIfMissing addVertexToMatrixIfMissing)
            {
                lock (Values)
                {
                    var vertex1InMatrix = this.IsVertexInMatrix(vertexPosition1);
                    var vertex2InMatrix = this.IsVertexInMatrix(vertexPosition2);
                    #region checkIfMissing
                    if (addVertexToMatrixIfMissing == AddVertexToMatrixIfMissing.No) // i.e. If we are not to add the vertex if it doesn't exist in the matrix:
                    {
                        // then if vertices are not in the matrix yet, throw an exception.
                        if (!vertex1InMatrix)
                        {
                            throw new ArgumentOutOfRangeException("vertexPosition1", "Vertex does not exist in matrix yet!");
                        }
                        if (!vertex2InMatrix)
                        {
                            throw new ArgumentOutOfRangeException("vertexPosition2", "Vertex does not exist in matrix yet!");
                        }
                    }
                    if (addVertexToMatrixIfMissing == AddVertexToMatrixIfMissing.Yes)
                    {
                        if (!vertex1InMatrix)  // then if vertices are not in the matrix yet, they should be added.
                        {
                            this.AddVertex(vertexPosition1);
                        }
                        if (!vertex2InMatrix)
                        {
                            this.AddVertex(vertexPosition2);
                        }

                    }
                    #endregion
                    // Now that both vertices are included in the matrix, we can set their adjacencies.
                    // This means vertexPosition1 should be true at vertexPosition2
                    //      and vertexPosition2 should be true at vertexPosition1.
                    Values[vertexPosition1][vertexPosition2] = true;
                    Values[vertexPosition2][vertexPosition1] = true;
                }
            
            }
            /// <summary>
            /// This method sets the adjacency indications on the adjacency matrix for the source vertex to each of the target vertices.
            /// </summary>
            /// <param name="vertexPosition1">Source vertex</param>
            /// <param name="vertexPositions">Target list.</param>
            /// <param name="addVertexToMatrixIfMissing"></param>
            public void SetAdjacentVertices(int vertexPosition1, IEnumerable<int> vertexPositions, AddVertexToMatrixIfMissing addVertexToMatrixIfMissing)
            {
                var vertexPositionsList = vertexPositions.ToList();
                lock (vertexPositionsList)
                {
                    lock (Values)
                    {
                        var vertex1InMatrix = this.IsVertexInMatrix(vertexPosition1);

                        var verticesNotInMatrix = vertexPositionsList.Where(t => !IsVertexInMatrix(t)).ToList();
                        #region checkIfMissing
                        if (addVertexToMatrixIfMissing == AddVertexToMatrixIfMissing.No) // i.e. If we are not to add the vertex if it doesn't exist in the matrix:
                        {
                            // then if vertices are not in the matrix yet, throw an exception.
                            if (!vertex1InMatrix)
                            {
                                throw new ArgumentOutOfRangeException("vertexPosition1", "Vertex does not exist in matrix yet!");
                            }
                            if (verticesNotInMatrix.Any())
                            {
                                throw new ArgumentOutOfRangeException("vertexPositions", "One or more vertices does not exist in matrix yet!");
                            }
                        }
                        if (addVertexToMatrixIfMissing == AddVertexToMatrixIfMissing.Yes)
                        {
                            if (!vertex1InMatrix)  // then if vertices are not in the matrix yet, they should be added.
                            {
                                this.AddVertex(vertexPosition1);
                            }
                            verticesNotInMatrix.ForEach(t => this.AddVertex(t)); // AddVertex vertices to matrix if missing.
                        }
                        #endregion
                        vertexPositionsList.ForEach(t => SetVertices(vertexPosition1, t));
                        // Now that both vertices are included in the matrix, we can set their adjacencies.
                    }
                }
            }

            /// <summary>
            /// This enum indicates whether or not a vertex should be added to this matrix if its identity is missing from the matrix.
            /// </summary>
            public enum AddVertexToMatrixIfMissing
            {
                Yes, 
                No
            }
            /// <summary>
            /// This enum indicates whether an exception should be thrown if one or more of the provided vertices already exist in this matrix.
            /// </summary>
            public enum ErrorOnDuplicate
            {
                Yes,
                No
            }

            /// <summary>
            /// This enum toggles whether or not an exception should be thrown if one or more of the provided values are not 
            /// in this matrix.
            /// </summary>
            public enum ErrorOnMissing
            {
                Yes,
                No
            }

            public enum AreVerticesAdjacent
            {
                BothVerticesAreAdjacent,
                SourceVertexIsAdjacentToTarget,
                TargetVertexIsAdjacentToSource,
                NeitherVerticesAreAdjacent,
                VertexIsMissingFromMatrix
            }

            
        }
        protected internal class UndirectedIncidenceProvider : IncidenceProvider
        {
            
            public UndirectedIncidenceProvider()
            {
                Values = new Dictionary<int, Dictionary<int, bool>>();
            }


            protected internal override void AddEdge(int edgePosition)
            {
                AddEdge(edgePosition, ErrorOnDuplicate.No);
            }
            private void AddEdge(int edgePosition, ErrorOnDuplicate errorOnDuplicate)
            {
                // Remember, when we add a new edge, we must add the new column to every row.
                lock (Values)
                {
                    if (!Values.Any())
                    {
                        AddVertex(0);
                    }
                    if (!this.IsEdgeInMatrix(edgePosition)) // i.e. if column is not in all rows.
                    {
                        foreach (var row in Values)  // then add the new column to every row
                        {
                            // AddVertex up to the missing edge.
                            for (int i = 0; i <= edgePosition; i++) // Performance can be improved if we only need to check the diff.
                            {
                                if (!row.Value.ContainsKey(i))
                                {
                                    row.Value.Add(i, false);
                                }
                            }

                            {
                                if (errorOnDuplicate == ErrorOnDuplicate.Yes)
                                {
                                    throw new IncidenceException("Duplicate edge = " + edgePosition + " detected!");
                                }
                            }

                        }
                    }

                }

            }
            private void AddVertex(int vertexPosition, ErrorOnDuplicate errorOnDuplicate)
            {
                lock (Values)
                {
                    if (!Values.Any())
                    {
                        // AddVertex values up to the specified vertex.
                        for (int i = 0; i <= vertexPosition; i++)
                        {
                            if (!Values.ContainsKey(i)) // if the row is missing, add it.
                            {
                                Values.Add(i, new Dictionary<int, bool>());
                                // Now that we've added a new row, we must create its columns up to the rowcount of the first row.
                                // AddVertex an entry for edge 0.
                                if (!Values[i].ContainsKey(0))
                                {
                                    Values[i].Add(0, false); // i.e. if the cell does not have a dictionary entry (for column 0), then add it. 
                                }

                            }
                        }
                    }
                    var columnCount = Values.FirstOrDefault().Value.Count; // We may also need to ensure that all required columns exist.
                    if (Values.ContainsKey(vertexPosition)) // If duplicate, throw exception if indicated.
                    {
                        if (Values[vertexPosition].Count == columnCount) // if column counts match, we should be okay.
                        {
                            if (errorOnDuplicate == ErrorOnDuplicate.Yes)
                            {
                                throw new IncidenceException("Duplicate vertex = " + vertexPosition + " deteted!");
                            }
                        }
                        else  // if column counts don't match, then we need to create some columns.
                        {
                            // At this point, we know that Values[vertexPosition] exists.
                            for (int i = 0; i < columnCount; i++)
                            {
                                if (!Values[vertexPosition].ContainsKey(i))
                                {
                                    Values[vertexPosition].Add(i, false);
                                }
                            } // Now that we've created the columns for the new row.

                        }

                    }
                    else // i.e. if row does not exist in matrix, we must create entries up to that row number.
                    {
                        for (int i = 0; i <= vertexPosition; i++)
                        {
                            if (!Values.ContainsKey(i)) // if the row is missing, add it.
                            {
                                Values.Add(i, new Dictionary<int, bool>());
                                // Now that we've added a new row, we must create its columns up to the rowcount of the first row.
                                for (int j = 0; j < columnCount; j++)
                                {
                                    Values[i].Add(j, false); // i.e. if the cell does not have a dictionary entry (for column), then add it.
                                }
                            }
                        }

                    }
                }
            }
            protected internal override void AddVertex(int vertexPosition)
            {
                AddVertex(vertexPosition, ErrorOnDuplicate.No);
            }

            /// <summary>
            /// This enum toggles whether or not an exception should be thrown if one or more of the provided values are not 
            /// in this matrix.
            /// </summary>
            public enum ErrorOnMissing
            {
                Yes,
                No
            }
            /// <summary>
            /// This enum indicates whether or not a vertex should be added to this matrix if its identity is missing from the matrix.
            /// </summary>
            public enum AddVertexToMatrixIfMissing
            {
                Yes,
                No
            }
            /// <summary>
            /// This enum indicates whether an exception should be thrown if one or more of the provided vertices already exist in this matrix.
            /// </summary>
            public enum ErrorOnDuplicate
            {
                Yes,
                No
            }

            private void SetIncidentVertex(int vertexPosition, int edgePosition)
            {
                Add(vertexPosition, edgePosition);
            }
           
        }
        // ----

        public NodeStateContextMediator()
        {

            NodeStateContextContainerFacade = new NodeStateContextContainerFacade<E,V>();
            IncidenceProvider = new UndirectedIncidenceProvider();
            AdjacencyProvider = new UndirectedAdjacencyProvider();
            GetIncidentVertexCache = new Dictionary<int, List<int>>();
            GetIncidentEdgeCache = new Dictionary<int, List<int>>();
            GetIncidentEdgeElementCache = new Dictionary<int, List<E>>();
            GetIncidentVertexElementCache = new Dictionary<int, List<V>>();
            IncidentVertexTupleCache = new Dictionary<int, Tuple<V, V>>();
        }
        /// <summary>
        /// This contains a cache of tuples of vertices, keyed by edgePosition.
        /// </summary>
        public Dictionary<int, Tuple<V, V>> IncidentVertexTupleCache { get; set; }
        /// <summary>
        /// This cache is used by GetIncidentVertices(..). 
        /// </summary>
        protected internal Dictionary<int, List<int>> GetIncidentVertexCache { get; set; }
        //protected internal Dictionary<int, List<V>> 
        /// <summary>
        /// This cache is used by GetIncidentEdges(..).
        /// </summary>
        protected internal Dictionary<int, List<int>> GetIncidentEdgeCache { get; set; }

        /// <summary>
        /// This cahce is used by GetIncidentEdgeElements(..). It stores a cache of the elements for the given vertexPosition.
        /// </summary>
        protected internal Dictionary<int, List<E>> GetIncidentEdgeElementCache { get; set; }

        /// <summary>
        /// This cache is used by This cahce is used by GetIncidentVertexElements(..). It stores a cache of the elements for the given edgePosition.
        /// </summary>
        protected internal Dictionary<int, List<V>> GetIncidentVertexElementCache { get; set; }
        public virtual NodeStateContextContainerFacade<E, V> NodeStateContextContainerFacade
        {
            get;
            set;
        }

        protected internal virtual UndirectedIncidenceProvider IncidenceProvider
        {
            get;
            set;
        }

        protected internal virtual AdjacencyProvider AdjacencyProvider
        {
            get;
            set;
        }

        public virtual IEnumerable<int> GetIncidentVertexPositions(int edgePosition)
        {
            return this.IncidenceProvider.GetIncidentVertexPositions(edgePosition);
        } 
        /// <summary>
        /// This method includes the sourceVertex in the result set.
        /// </summary>
        /// <param name="sourceVertex"></param>
        /// <returns></returns>
        public virtual IEnumerable<int> GetAdjacentVertexPositionsInclusive(int sourceVertex)
        {
            return this.AdjacencyProvider.GetAdjacentVertexPositionsInclusive(sourceVertex);
        } 
        public virtual V GetVertexNodeStateContextByPosition(int vertexPosition)
        {
            return this.NodeStateContextContainerFacade.GetVertexNodeStateContextByPosition(vertexPosition);
        }
        public virtual E GetEdgeNodeStateContextByPosition(int edgePosition)
        {
            return this.NodeStateContextContainerFacade.GetEdgeNodeStateContextByPosition(edgePosition);
        }
        
        public virtual IEnumerable<int> GetEdgeAdjacencyIntersection(int edgePosition)
        {
            var adjacentVertexTuple = this.GetIncidentVerticesAsTuple(edgePosition);
            var vertex1AdjacentHashset = this.GetAdjacentVertexPositionsInclusive(adjacentVertexTuple.Item1.Position);
            var vertex2AdjacentHashset = this.GetAdjacentVertexPositionsInclusive(adjacentVertexTuple.Item2.Position);
            var hashsetIntersection = vertex1AdjacentHashset.Intersect(vertex2AdjacentHashset);
            return hashsetIntersection;
        }

        public virtual void ApplyActionToEdges(Action<EdgeNode> edgeAction)
        {
            foreach (var edgeNode in EdgeNodeFactory.GetFactory().Values)
            {
                edgeAction.Invoke(edgeNode.Value);
            }
        }
        /// <summary>
        /// This method computes the intersection between the adjacency sets of both vertices incident to the given edge, for every edge in the EdgeNodeFactory.
        /// </summary>
        public virtual void ApplyAdjacencyIntersectionValuesToAllEdgesInGraph()
        {
            ApplyActionToEdges(t => t.ValueSet = this.GetEdgeAdjacencyIntersection(t.Position).ToHashSet());
        }
        public virtual Dictionary<int, E> EdgeNodeStateContexts
        {
            get { return this.NodeStateContextContainerFacade.EdgeNodeStateContexts; }
        }
        public virtual Dictionary<int, V> VertexNodeStateContexts
        {
            get { return this.NodeStateContextContainerFacade.VertexNodeStateContexts; }
        } 

        public virtual void AddVertex(int vertexPosition, VertexNodeStateContextFactory<V> factory)
        {
            this.NodeStateContextContainerFacade.AddVertex(vertexPosition, factory);
            this.IncidenceProvider.AddVertex(vertexPosition);
            this.AdjacencyProvider.AddVertex(vertexPosition);
        }
        public virtual void AddVertex(int vertexPosition, int vertexValue, int vertexClause, VertexNodeStateContextFactory<V> factory)
        {
            this.NodeStateContextContainerFacade.AddVertex(vertexPosition, vertexValue, vertexClause, factory);
            this.IncidenceProvider.AddVertex(vertexPosition);
            this.AdjacencyProvider.AddVertex(vertexPosition);
        }

        public virtual void AddVertices(int sourceVertexPosition, int[] targetVertexPositions)
        {
            this.AddVertices(sourceVertexPosition, targetVertexPositions, new EdgeNodeStateContextFactory<E>(), new VertexNodeStateContextFactory<V>());
        }
        protected internal virtual void AddVertices(int sourceVertexPosition, int targetVertex, EdgeNodeStateContextFactory<E> edgeFactory, VertexNodeStateContextFactory<V> vertexFactory)
        {
            lock (this.IncidenceProvider.Values)
            {
                var edgePosition = this.IncidenceProvider.SetVertices(sourceVertexPosition, targetVertex);
                lock (this.NodeStateContextContainerFacade)
                {
                    this.NodeStateContextContainerFacade.AddEdge(edgePosition, edgeFactory);
                }
            }
            lock (this.AdjacencyProvider.Values)
            {
                this.AdjacencyProvider.SetVertices(sourceVertexPosition, targetVertex);
                lock (this.NodeStateContextContainerFacade)
                {
                    NodeStateContextContainerFacade.AddVertex(sourceVertexPosition, vertexFactory);
                    NodeStateContextContainerFacade.AddVertex(targetVertex, vertexFactory);
                }
            }
        }
        protected internal virtual void AddVertices(int sourceVertexPosition, int[] targetVertexPositions, EdgeNodeStateContextFactory<E> edgeFactory, VertexNodeStateContextFactory<V> vertexFactory)
        {
            lock (this.IncidenceProvider.Values)
            {
                var edgePositionList = this.IncidenceProvider.SetVertices(sourceVertexPosition, targetVertexPositions);
                lock (this.NodeStateContextContainerFacade)
                {
                    edgePositionList.ForEach(t => this.NodeStateContextContainerFacade.AddEdge(t, edgeFactory));
                }
            }
            lock (this.AdjacencyProvider.Values)
            {
                this.AdjacencyProvider.SetVertices(sourceVertexPosition, targetVertexPositions);
                lock (this.NodeStateContextContainerFacade)
                {
                    NodeStateContextContainerFacade.AddVertex(sourceVertexPosition, vertexFactory);
                    targetVertexPositions.ToList().ForEach(t => NodeStateContextContainerFacade.AddVertex(t, vertexFactory));
                }
            }
        }
        protected internal virtual void AddEdge(int edgePosition, EdgeNodeStateContextFactory<E> factory)
        {
            this.NodeStateContextContainerFacade.AddEdge(edgePosition, factory);
            this.IncidenceProvider.AddEdge(edgePosition);
        }

        public virtual void CutEdge(int vertexPosition1, int vertexPosition2)
        {
            // first we must retrieve the edge's context.
            var specifiedEdge = this.GetEdgeIncidentToBothVertices(vertexPosition1, vertexPosition2);
            // Then, we must change its state.
            specifiedEdge.Cut();
            
        }
        /// <summary>
        /// This method deletes the edge between the two specified vertices. The deletion affects
        /// the incidence matrix, adjacency matrix, AND the container. (The nodeStateContext element in the
        /// container is deleted from the container.)
        /// </summary>
        /// <param name="vertexPosition1"></param>
        /// <param name="vertexPosition2"></param>
        public virtual void DeleteEdge(int vertexPosition1, int vertexPosition2)
        {
            lock (AdjacencyProvider.Values)
            {
                lock (IncidenceProvider.Values)
                {
                    var incidentEdge = this.GetEdgeIncidentToBothVertices(vertexPosition1, vertexPosition2);
                    lock (GetIncidentEdgeCache)
                    {
                        if (GetIncidentEdgeCache.ContainsKey(incidentEdge.Position))
                        {
                            GetIncidentEdgeCache.Remove(incidentEdge.Position);
                        }
                    }
                    lock (GetIncidentEdgeElementCache)
                    {
                        if (GetIncidentEdgeElementCache.ContainsKey(incidentEdge.Position))
                        {
                            GetIncidentEdgeElementCache.Remove(incidentEdge.Position);
                        }
                    }
                    //if (DoesCutOrphanVertex(vertexPosition1, vertexPosition2))
                    //{
                    //    throw new AdjacencyException("Error: The requested cut would orphan a vertex!");
                    //}
                    
                    this.AdjacencyProvider.UnsetVertices(vertexPosition1, vertexPosition2);
                    this.IncidenceProvider.UnsetVertices(vertexPosition1, vertexPosition2);

                    this.NodeStateContextContainerFacade.EdgeNodeStateContextContainer.Values.Remove(
                        incidentEdge.Position);
                    
                }
            }
        }

        public virtual void DeleteVertex(int vertexPosition)
        {
            lock (GetIncidentVertexCache)
            {
                if (GetIncidentVertexCache.ContainsKey(vertexPosition))
                {
                    GetIncidentVertexCache.Remove(vertexPosition);
                }
               
            }
            lock (GetIncidentVertexElementCache)
            {
                if (GetIncidentVertexElementCache.ContainsKey(vertexPosition))
                {
                    GetIncidentVertexElementCache.Remove(vertexPosition);
                }
            }
            throw new System.NotImplementedException();
        }
       
        
        /// <summary>
        /// This method returns the incident vertices' positions for the given edgePosition.
        /// </summary>
        /// <param name="edgePosition"></param>
        /// <returns></returns>
        public virtual List<int> GetIncidentVertices(int edgePosition)
        {
            
            if (this.GetIncidentVertexCache.ContainsKey(edgePosition))
            {
                return this.GetIncidentVertexCache[edgePosition];
            }
            
            var vertices = this.IncidenceProvider.GetIncidentVertices(edgePosition);
            lock (GetIncidentVertexCache)
            {    
                this.GetIncidentVertexCache.Add(edgePosition, vertices);
                return vertices;
            }
            
        }

        public virtual IEnumerable<int> GetAdjacentVertices(int sourceVertexPosition)
        {
            return this.AdjacencyProvider.GetAdjacentVertices(sourceVertexPosition);
        } 
        public virtual Tuple<V, V> GetIncidentVerticesAsTuple(int edgePosition)
        {
            if (IncidentVertexTupleCache.ContainsKey(edgePosition))
            {
                return IncidentVertexTupleCache[edgePosition];
            }
            else
            {
                var vertices = this.GetIncidentVertexElements(edgePosition);
                var tuple = new Tuple<V, V>(vertices[0], vertices[1]);
                lock (IncidentVertexTupleCache)
                {
                    IncidentVertexTupleCache.Add(edgePosition, tuple);
                }
                return tuple;
            }
            

        }
        /// <summary>
        /// This method returns the incident vertices to the given edgePosition.
        /// </summary>
        /// <param name="edgePosition"></param>
        /// <returns></returns>
        public virtual List<V> GetIncidentVertexElements(int edgePosition)
        {
            lock (this.GetIncidentVertexElementCache)
            {
                if (this.GetIncidentVertexElementCache.ContainsKey(edgePosition))
                {
                    return this.GetIncidentVertexElementCache[edgePosition];
                }
               
                var vertexPositions = this.GetIncidentVertices(edgePosition);
                var vertexElements = new List<V>();
                foreach (var vertexPosition in vertexPositions)
                {
                    var element =
                        NodeStateContextContainerFacade.VertexNodeStateContextContainer.GetNodeByPosition(vertexPosition);
                    if (element != null)
                    {
                        vertexElements.Add(element);
                    }
                }
           
                this.GetIncidentVertexElementCache.Add(edgePosition, vertexElements);
                return vertexElements;
            }
        } 
        /// <summary>
        /// This method returns the incident edges' positions for the given vertexPosition.
        /// </summary>
        /// <param name="vertexPosition"></param>
        /// <returns></returns>
        public virtual List<int> GetIncidentEdges(int vertexPosition)
        {
            lock (this.GetIncidentEdgeCache)
            {
                if (this.GetIncidentEdgeCache.ContainsKey(vertexPosition))
                {
                    return this.GetIncidentEdgeCache[vertexPosition];
                }
                var edges = this.IncidenceProvider.GetIncidentEdges(vertexPosition);
            
                this.GetIncidentEdgeCache.Add(vertexPosition, edges);
                return edges;
            }
        }

        
        /// <summary>
        /// This method returns the edge elements incident to the given vertexPosition.
        /// </summary>
        /// <param name="vertexPosition"></param>
        /// <returns></returns>
        public virtual List<E> GetIncidentEdgeElements(int vertexPosition)
        {
            lock (this.GetIncidentEdgeElementCache)
            {
                if (this.GetIncidentEdgeElementCache.ContainsKey(vertexPosition))
                {
                    return this.GetIncidentEdgeElementCache[vertexPosition];
                }
            
                var edgePositions = this.GetIncidentEdges(vertexPosition);
                var edgeElements = new List<E>();
                foreach (var edgePosition in edgePositions)
                {
                    var element =
                        NodeStateContextContainerFacade.EdgeNodeStateContextContainer.GetNodeByPosition(edgePosition);
                    if (element != null)
                    {
                        edgeElements.Add(element);
                    }
                }
            
                this.GetIncidentEdgeElementCache.Add(vertexPosition, edgeElements);
                return edgeElements;
            }
        }

        public bool IsVertexInMatrix(int vertexPosition)
        {
            var isVertexInMatrix = this.IncidenceProvider.IsVertexInMatrix(vertexPosition);
            return isVertexInMatrix;
        }
        public virtual IEnumerable<int> GetEdgesIncidentToBothVertices(int vertexPosition1, int vertexPosition2)
        {
            var edges = this.IncidenceProvider.GetEdgesIncidentToBothVertices(vertexPosition1, vertexPosition2);
            return edges;
        }

        public virtual E GetEdgeIncidentToBothVertices(int vertexPosition1, int vertexPosition2)
        {
            var edges = this.IncidenceProvider.GetEdgesIncidentToBothVertices(vertexPosition1, vertexPosition2).ToList();
            if (edges.Count > 1)
            {
                throw new TooManyEdgesException(vertexPosition1, vertexPosition2);
            }
            if (!edges.Any())
            {
                throw new NotEnoughEdgesException(
                    "See GetEdgeIncidentToBothVertices() in AdjacencyMatrixDictionaryDirector. ", vertexPosition1,
                    vertexPosition2);
            }
            var firstEdge = edges.FirstOrDefault();
            // what is firstEdge if no edges exist?
            var nodeContext = this.NodeStateContextContainerFacade.EdgeNodeStateContextContainer.GetNodeByPosition(firstEdge);
            return nodeContext;
        }

        public virtual bool AreVerticesBothAdjacentAndUncut(int vertexPosition1, int vertexPosition2)
        {
            lock (AdjacencyProvider.Values)
            {
                return this.AdjacencyProvider.AreVerticesBothAdjacentAndUncut(this, vertexPosition1, vertexPosition2);
            }
        }
        protected internal virtual IEnumerable<E> GetIncidentEdgeNodesWithState(int vertexPosition, NodeState state)
        {
            var incidentEdgePositions = this.IncidenceProvider.GetIncidentEdges(vertexPosition);
            var edgeNodesWithState = incidentEdgePositions.Select(
                t => this.NodeStateContextContainerFacade.EdgeNodeStateContextContainer.GetNodeByPosition(t))
                .Where(t => t.State.Equals(state));
            return edgeNodesWithState;
        }
        protected internal virtual IEnumerable<E> GetIncidentEdgeNodesWithoutState(int vertexPosition, NodeState state)
        {
            var incidentEdgePositions = this.IncidenceProvider.GetIncidentEdges(vertexPosition);
            var edgeNodesWithState = incidentEdgePositions.Select(
                t => this.NodeStateContextContainerFacade.EdgeNodeStateContextContainer.GetNodeByPosition(t))
                .Where(t => !t.State.Equals(state));
            return edgeNodesWithState;
        }
        protected internal virtual IEnumerable<E> GetIncidentEdgeNodesWithStateUncut(int vertexPosition)
        {
            return GetIncidentEdgeNodesWithoutState(vertexPosition, CutEdgeNodeState.Instance);
        }
        protected internal virtual int GetIncidentUncutEdgeCount(
            int vertexPosition)
        {
            return GetIncidentEdgeNodesWithStateUncut(vertexPosition).ToList().Count;
        }
        protected internal virtual bool IsIncidentUncutEdgeCountAboveTwo(
            int vertexPosition)
        {
            return this.GetIncidentUncutEdgeCount(vertexPosition) > 2;
        }
        protected internal virtual IEnumerable<E> GetIncidentEdgeNodesWithStateUnchosen(int vertexPosition)
        {
            return GetIncidentEdgeNodesWithState(vertexPosition, UnchosenEdgeNodeState.Instance);
        }
        protected internal virtual IEnumerable<E> GetIncidentEdgeNodesWithStateUnchosen(V sourceVertex)
        {
            return GetIncidentEdgeNodesWithState(sourceVertex.Position, UnchosenEdgeNodeState.Instance);
        }
        protected internal virtual IEnumerable<E> GetEdgeNodesWithStateChosenMale
        {
            get { return this.NodeStateContextContainerFacade.GetEdgeNodesWithState(MaleChosenEdgeNodeState.Instance); }
        }
        protected internal virtual IEnumerable<E> GetEdgeNodesWithStateChosenFemale
        {
            get { return this.NodeStateContextContainerFacade.GetEdgeNodesWithState(FemaleChosenEdgeNodeState.Instance); }
        }
        protected internal virtual IEnumerable<V> GetVertexNodesWithStateChosenMale 
        {
            get
            {
                return this.NodeStateContextContainerFacade.GetVertexNodesWithState(MaleChosenVertexNodeState.Instance);
            }
        }
        protected internal virtual IEnumerable<V> GetVertexNodesWithStateChosenFemale
        {
            get
            {
                return this.NodeStateContextContainerFacade.GetVertexNodesWithState(FemaleChosenVertexNodeState.Instance);
            }
        }
        /// <summary>
        /// Node: This method only clones the containerFacade and its contexts!
        /// It does not clone the AdjacencyProvider or IncidenceProvider, 
        /// so those providers use the existing object references!
        /// </summary>
        /// <param name="nodeStateContextMediator"></param>
        /// <param name="facadeFlyweightFactory"></param>
        /// <returns></returns>
        public  NodeStateContextMediator<E,V> Copy(
            NodeStateContextContainerFacadeFlyweightFactory<E,V> facadeFlyweightFactory)
        {
            var facadeCopy = this.NodeStateContextContainerFacade.Copy(facadeFlyweightFactory);
            var mediatorCopy = new NodeStateContextMediator<E,V>
            {
                NodeStateContextContainerFacade = facadeCopy,
                AdjacencyProvider = this.AdjacencyProvider,
                IncidenceProvider = this.IncidenceProvider
            };
            return mediatorCopy;
        }
        
    }
}

