//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Nucleotide_v3.Exceptions;
using Nucleotide_v3.States;

namespace Nucleotide_v3.Model
{
    [DebuggerDisplay("Position={Position}, State={State}")]
    [Serializable]
    public class EdgeNodeStateContext : NodeStateContext 
    {
        //public new virtual VertexNode Node { get; set; }
        public EdgeNode NodeAsEdgeNode
        {
            get { return (EdgeNode) this.Node; }
        }
        public new virtual EdgeNodeState State
        {
            get { return (EdgeNodeState)base.State; }
            set { base.State = value; } // what's best way to check if state is valid for this class?
        }

        //public new virtual EdgeNode Node { get; set; }
         [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        protected internal virtual void Choose(NodeState.NodeGender gender)
        {
            this.State.Choose(this, gender);
        }
       [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void ChooseAsMale()
        {
            this.State.Choose(this, NodeState.NodeGender.Male);
        }
        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void ChooseAsFemale()
        {
            this.State.Choose(this, NodeState.NodeGender.Female);
        }

        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void Cut()
        {
            this.State = CutEdgeNodeState.Instance;
        }
         [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void Reset()
        {
            this.State = UnchosenEdgeNodeState.Instance;
        }

        protected internal EdgeNodeStateContext(EdgeNode node, EdgeNodeState state) : base(node, state)
        {

        }

        protected internal virtual IEnumerable<V> GetIncidentVertices<E,V>(NodeStateContextMediator<E, V> mediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var vertexContexts = mediator.GetIncidentVertexElements(this.Position);
            return vertexContexts;
        }

        protected internal virtual IEnumerable<V> GetIncidentVerticesWithSpecifiedState<E,V>(
            NodeStateContextMediator<E, V> mediator,
            VertexNodeState state) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return this.GetIncidentVertices(mediator).Where(t => t.State.Equals(state));
        }

        protected internal virtual IEnumerable<V> GetIncidentVerticesWithoutSpecifiedState<E,V>(
            NodeStateContextMediator<E, V> mediator,
            VertexNodeState state) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return this.GetIncidentVertices(mediator).Where(t => !t.State.Equals(state));
        }

        /// <summary>
        /// This constructor defaults to UnchosenEdgeNodeState.
        /// </summary>
        /// <param name="node"></param>
        protected internal EdgeNodeStateContext(EdgeNode node)
            : base(node, UnchosenEdgeNodeState.Instance)
        {

        }

        public EdgeNodeStateContext() : base()
        {

        }
        public E Copy<E>(EdgeNodeStateContext nodeStateContext, EdgeNodeStateContextFactory<E> factory) where E:EdgeNodeStateContext, new()
        {
            var nodeFactory = EdgeNodeFactory.GetFactory();
            var context = factory.ConstructNodeContext(nodePosition: nodeStateContext.Node.Position,
                nodeState: nodeStateContext.State, nodeFactory: nodeFactory);
            return context;
        }

        /// <summary>
        /// The elements in the resulting tuple are not ordered.
        /// </summary>
        /// <param name="mediator"></param>
        /// <returns></returns>
        protected internal virtual Tuple<V, V> GetIncidentVerticesAsTuple<E,V>(
            NodeStateContextMediator<E, V> mediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            //var vertices = this.GetIncidentVertices(mediator).ToList();
            //if (vertices.Count < 2)
            //{
            //    throw new NotEnoughEdgesException();
            //}
            //if (vertices.Count > 3)
            //{
            //    throw new TooManyEdgesException();
            //}
            //var firstVertex = vertices[0];
            //var secondVertex = vertices[1];
            //var tuple = new Tuple<V, V>(firstVertex, secondVertex);
            var tuple = mediator.GetIncidentVerticesAsTuple(this.Position);
            return tuple;
        }

        /// <summary>
        /// This method checks both vertices (that are incident to this edge) to determine if a cut to the edge would orphan either one of them.
        /// If either vertex would be orphaned, this method returns true. For a vertex to be determined to be orphaned, it must have 
        /// 2 or fewer incident edges total where edgeState != cut. (Thus, it must have 2 or fewer edges that are either chosen or unchosen 
        /// before a cut is attempted.) This is because a cut would reduce the set of {chosen or unchosen edges} to 1 or fewer.
        /// </summary>
        /// <param name="nodeStateContextMediator"></param>
        /// <returns></returns>
        protected internal virtual bool DoesCutOrphanVertex<E,V>(NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var incidentVertices = this.GetIncidentVerticesAsTuple(nodeStateContextMediator);
            var wouldCutOrphanFirstVertex =
                incidentVertices.Item1.WouldCutOrphanVertex(nodeStateContextMediator);
            if (wouldCutOrphanFirstVertex)
            {
                return true;
            }
            var wouldCutOrphanSecondVertex = incidentVertices.Item2.WouldCutOrphanVertex(nodeStateContextMediator);
            if (wouldCutOrphanSecondVertex)
            {
                return true;
            }
            return false;
        }

        protected internal virtual bool DoesCutOrphanTargetVertex<E,V>(NodeStateContextMediator<E, V> nodeStateContextMediator,
            int sourceVertexPosition) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var incidentVertices = this.GetIncidentVertices(nodeStateContextMediator).ToList();
            if (incidentVertices.Count > 2)
            {
                throw new NotEnoughEdgesException("Unexpected number of incident vertices!");
            }
            var targetVertex = incidentVertices.FirstOrDefault(t => t.Position != sourceVertexPosition);

            if (targetVertex == null)
            {
                throw new NullReferenceException("Problem in DoesCutOrphanTargetVertex(..)");
            }

            var wouldCutOrphanSecondVertex = targetVertex.WouldCutOrphanVertex(nodeStateContextMediator);
            if (wouldCutOrphanSecondVertex)
            {
                return true;
            }
            return false;
        }

        protected internal virtual bool DoesCutOrphanTargetVertex<E,V>(NodeStateContextMediator<E, V> nodeStateContextMediator,
            V sourceVertex) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return this.DoesCutOrphanTargetVertex(nodeStateContextMediator, sourceVertex.Position);
        }


        protected internal virtual IEnumerable<V> GetIncidentUnchosenVertexNodeStateContexts<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return this.GetIncidentVerticesWithSpecifiedState(nodeStateContextMediator, UnchosenVertexNodeState.Instance);
        }

        /// <summary>
        /// This method assumes that only one of the incident vertices is unchosen!
        /// (It assumes that the other incident vertex is chosen!)
        /// </summary>
        /// <param name="nodeStateContextMediator"></param>
        /// <returns></returns>
        protected internal virtual V GetIncidentUnchosenVertexNodeStateContext<E, V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var unchosenVertices = this.GetIncidentUnchosenVertexNodeStateContexts(nodeStateContextMediator).ToList();
            if (unchosenVertices.Count > 1)
            {
                throw new TooManyVerticesException("problem in GetIncidentUnchosenVertexNodeStateContext(..)!");
            }
            if (unchosenVertices.Count < 1)
            {
                return null;
                //throw new NotEnoughVerticesException("problem in GetIncidentUnchosenVertexNodeStateContext(..)!");
            }
            var firstUnchosenVertex = unchosenVertices.FirstOrDefault();
            if (firstUnchosenVertex == null)
            {
                throw new NullReferenceException(
                    "firstUnchosenVertex is null in GetIncidentUnchosenVertexNodeStateContext(..)!");
            }
            return firstUnchosenVertex;
        }
    }
}

