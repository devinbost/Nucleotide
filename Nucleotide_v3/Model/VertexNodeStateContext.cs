//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using Nucleotide_v3.Exceptions;
using Nucleotide_v3.States;

namespace Nucleotide_v3.Model
{
    [DebuggerDisplay("Position={Position}, State={State}")]
    [Serializable]
    public class VertexNodeStateContext : NodeStateContext
    {
        //public new virtual VertexNode Node { get; set; }
        public VertexNode NodeAsVertexNode
        {
            get { return (VertexNode)this.Node; }
        }
        protected internal VertexNodeStateContext(VertexNode node, VertexNodeState state)
            : base(node, state)
        {

        }

        
        /// <summary>
        /// This constructor defaults to UnchosenVertexNodeState.
        /// </summary>
        /// <param name="node"></param>
        protected internal VertexNodeStateContext(VertexNode node)
            : base(node, UnchosenVertexNodeState.Instance)
        {

        }

        public VertexNodeStateContext()
            : base()
        {

        }
        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        protected internal void Choose(NodeState.NodeGender gender)
        {
            this.State.Choose(this, gender);
        }
        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void Reset()
        {
            this.State.Reset(this);
        }
        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void ChooseAsMale()
        {
            this.State.Choose(this, NodeState.NodeGender.Male);
        }
        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void ChooseAsFemale()
        {
            this.State.Choose(this, NodeState.NodeGender.Female);
        }
        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        public virtual void ChooseAsOrigin()
        {
            this.State.ChooseAsOrigin(this);
        }

        public new virtual VertexNodeState State
        {
            get { return (VertexNodeState)base.State; }
            set { base.State = value; }
        }

        protected internal virtual List<E> GetIncidentEdgeNodeStateContexts<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return nodeStateContextMediator.GetIncidentEdgeElements(this.Position);
        }
        protected internal virtual List<E> GetIncidentEdgeNodeStateContextsWithMatchingState<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator, NodeState state)  where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return nodeStateContextMediator.GetIncidentEdgeElements(this.Position).Where(t => t.State.Equals(state)).ToList();
        }
        protected internal virtual List<E> GetIncidentEdgeNodeStateContextsWithNotMatchingState<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator, NodeState state) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return nodeStateContextMediator.GetIncidentEdgeElements(this.Position).Where(t => !t.State.Equals(state)).ToList();
        }
        protected internal virtual List<E> GetIncidentEdgeNodeStateContextsWhereStateIsNotCut<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return GetIncidentEdgeNodeStateContextsWithNotMatchingState(nodeStateContextMediator,
                CutEdgeNodeState.Instance);
        }

        //protected internal virtual List<V> GetAdjacentVertexNodeStateContexts<E, V>(
        //    NodeStateContextMediator<E, V> nodeStateContextMediator)
        //    where E : EdgeNodeStateContext, new()
        //    where V : VertexNodeStateContext, new()
        //{
        //    return nodeStateContextMediator.GetAdjacentVertices(this.Position)
        //}
        /// <summary>
        /// This method must be called before the cut actually occurs. 
        /// It checks if the number of incident edgeNodeStateContexts with state != CutEdgeNodeState
        /// is greater than 2. If so, it returns false because there are enough free edges for the 
        /// cut to not cause an orphan. But if the value is 2 or below, then it returns true because
        /// the cut would cause this vertex to be orphaned.
        /// </summary>
        /// <param name="nodeStateContextMediator"></param>
        /// <returns></returns>
        protected internal virtual bool WouldCutOrphanVertex<E,V>(NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var incidentEdgeNodeContextsWhereStateIsNotCut =
                this.GetIncidentEdgeNodeStateContextsWhereStateIsNotCut(nodeStateContextMediator);
            if (incidentEdgeNodeContextsWhereStateIsNotCut.Count > 2)
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        protected internal virtual IEnumerable<E> GetIncidentUncutEdges<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return nodeStateContextMediator.GetIncidentEdgeNodesWithStateUncut(this.Position);
        }

        protected internal virtual Dictionary<int, bool> WouldCutToIncidentUnchosenEdgesOrphanTargetVertexDictionary<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var unchosenEdges = this.GetIncidentEdgeNodeStateContextsWithMatchingState(nodeStateContextMediator, UnchosenEdgeNodeState.Instance);
            var doesCutOrphanVertex = unchosenEdges.ToDictionary(t => t.Position,
                t => t.DoesCutOrphanTargetVertex(nodeStateContextMediator, this.Position));
            return doesCutOrphanVertex;
        }

        protected internal virtual IEnumerable<E> GetUnchosenEdgesThatCauseOrphans<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var causingOrphansDict = this.WouldCutToIncidentUnchosenEdgesOrphanTargetVertexDictionary(nodeStateContextMediator);
            var unchosenEdgesThatCauseOrphans = causingOrphansDict.Where(t => t.Value).Select(t => nodeStateContextMediator.GetEdgeNodeStateContextByPosition(t.Key));
            return unchosenEdgesThatCauseOrphans;
        }
        protected internal virtual int GetNumberOfIncidentEdgesThatOrphanTargetVertex<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var incidentEdgesThatOrphanVertex =
                this.WouldCutToIncidentUnchosenEdgesOrphanTargetVertexDictionary(nodeStateContextMediator);
            var countOfValuesThatAreTrue = incidentEdgesThatOrphanVertex.Where(t => t.Value).Count();
            return countOfValuesThatAreTrue;
        }
        protected internal virtual int GetUncutEdgeCount<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return this.GetIncidentUncutEdges(nodeStateContextMediator).ToList().Count;
        }
        protected internal virtual bool IsUncutEdgeCountAboveTwo<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return this.GetUncutEdgeCount(nodeStateContextMediator) > 2;
        }

        protected internal virtual int NumberOfEdgesThatCanBeCut<E,V>(NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var uncutEdgeCount = this.GetUncutEdgeCount(nodeStateContextMediator);
            return uncutEdgeCount - 2;
        }

        protected internal virtual IEnumerable<E> GetIncidentUnchosenEdgeNodeStateContexts<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            return this.GetIncidentEdgeNodeStateContextsWithMatchingState(nodeStateContextMediator,
                        UnchosenEdgeNodeState.Instance);
        }
        protected internal virtual void CutRemainingUnchosenEdges2<E, V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator)
            where E : EdgeNodeStateContext, new()
            where V : VertexNodeStateContext, new()
        {
            var incidentUnchosenEdgeNodes = this.GetIncidentUnchosenEdgeNodeStateContexts(nodeStateContextMediator).ToList();
            incidentUnchosenEdgeNodes.ForEach(t => nodeStateContextMediator.NodeStateContextContainerFacade.CutEdge(t));
        }
        [Obsolete("Warning: Use the method on the container. This affects a flyweight.")]
        protected internal virtual void CutRemainingUnchosenEdges<E,V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            var incidentUnchosenEdgeNodes = this.GetIncidentUnchosenEdgeNodeStateContexts(nodeStateContextMediator).ToList();
            incidentUnchosenEdgeNodes.ForEach(t => t.Cut());
        }
        public static VertexNodeStateContext Copy(VertexNodeStateContext nodeStateContext, VertexNodeStateContextFactory<VertexNodeStateContext> factory)
        {
            var nodeFactory = VertexNodeFactory.GetFactory();
            var context = factory.ConstructNodeContext(nodePosition: nodeStateContext.Node.Position,
                nodeState: nodeStateContext.State, nodeFactory: nodeFactory);
            return context;
        }
        /// <summary>
        /// This method assumes that this vertex has already been chosen.
        /// </summary>
        /// <param name="nodeStateContextMediator"></param>
        /// <returns></returns>
        protected internal virtual List<E> GetEdgesThatCutWouldOrphanIfAnyOrGetDefaultUnchosenEdgesIfNone<E, V>(
            NodeStateContextMediator<E, V> nodeStateContextMediator) where E:EdgeNodeStateContext, new() where V:VertexNodeStateContext , new()
        {
            List<E> unchosenIncidentEdgeNodes;
            var numberOfEdgesThatOrphanTargetVertex =
                this.GetNumberOfIncidentEdgesThatOrphanTargetVertex(nodeStateContextMediator);
            if (numberOfEdgesThatOrphanTargetVertex == 0)
            {
                unchosenIncidentEdgeNodes = nodeStateContextMediator.GetIncidentEdgeNodesWithStateUnchosen(this.Position).ToList();
            }
            else // i.e. if at least one unchosen edge orphans the target vertex, then add them all  
            {    // because either 1 edge creates an orphan and must be chosen or more exist and must be evaluated as a best-try attempt (even though hamiltonicity is not possible for all vertices in this case).
                unchosenIncidentEdgeNodes = this.GetUnchosenEdgesThatCauseOrphans(nodeStateContextMediator).ToList();
               
                if (numberOfEdgesThatOrphanTargetVertex > 1)
                {
                    return unchosenIncidentEdgeNodes; // I could return these if I want to continue traversing the graph even though it's not hamiltonian for all vertices in this case.
                    //return null; // I could return null if I want to stop traversing the graph.
                    // perhaps we should return null here and check for null at the call site.
                    //throw new TooManyEdgesException("We need to deal with this case for the vertex with position: " + this.Position);
                }
            }
            return unchosenIncidentEdgeNodes;
        }
        public V Copy<V>(VertexNodeStateContext nodeStateContext, VertexNodeStateContextFactory<V> factory) where V : VertexNodeStateContext, new()
        {
            var nodeFactory = VertexNodeFactory.GetFactory();
            var context = factory.ConstructNodeContext(nodePosition: nodeStateContext.Node.Position,
                nodeState: nodeStateContext.State, nodeFactory: nodeFactory);
            return context;
        }
        
    }
}

